#!/usr/bin/env bash

filename=''
window_scale=1
print_help=0
watch=0
dry_run=0
clean=0

for i in "$@"; do
    case "$i" in
        --wipe)
            make -C emu wipe
            clean=1
            ;;
        --clean)
            make -C emu clean
            clean=1
            ;;
        --scale)
            echo "ERROR: --scale flag must have an argument." >&2
            exit 1
            ;;
        --scale=*)
            window_scale="${i#*=}"
            ;;
        --watch|-w)
            watch=1
            ;;
        --dry-run|-d)
            dry_run=1
            ;;
        --help|-h) print_help=1 ;;
        *)
            filename="$i"
            if [ ! -f "$filename" ]; then
                echo "ERROR: no such file '$filename'" >&2
                exit 1
            fi
            ;;
    esac
done

if [ "$clean" == 1 ] && [ -z "$filename" ]; then
    exit 0
fi

if [ -z "$filename" ] || [ "$print_help" == 1 ]; then
    echo "Usage: [FLAGS] $0 <ino/xml file>" >&2
    echo >&2
    echo "Flags:" >&2
    echo "  --clean         | Remove build files." >&2
    echo "  --wipe          | Remove all build and temp files." >&2
    echo "  --scale=[SCALE] | Scale the window by an integer amount." >&2
    echo "  --watch,   -w   | Watch for source changes, automatically rebuilding when a change is detected." >&2
    echo "  --dry-run, -d   | Verify compilation and exit." >&2
    echo "  --help     -h   | Display this message." >&2
    [ "$print_help" == 0 ] && exit 1
    exit 0
fi

tmpfile() {
    mktemp 2>/dev/null && return 0
    local t
    t="/tmp/giga_emu_$(uuidgen)"
    touch "$t" || return 1
    echo "$t"
}

move_file() {
    if [[ "$filename" == *.xml ]]; then
        local tmp
        tmp=$(tmpfile)
        if ! tools/xml_to_ui.py "$filename" -f build_ui > "$tmp"; then
            rm -f "$tmp"
            return 1
        fi
        echo "
        $(cat "$tmp")
        void setup() {
            ui::begin();
            ui::setRoot(build_ui());
        }

        void loop() {
            ui::render();
        }
        " > emu/ino.cpp
        rm -f "$tmp"
    else
        rsync "$filename" emu/ino.cpp || return 1
    fi
    return 0
}

build() {
    move_file || return 1
    rsync -a src emu/ -u || return 1
    make -C emu WINDOW_SCALE="$window_scale" || return 1

    echo -e "\e[32mBuild Successful.\e[0m"
    return 0
}

if [ $watch == 0 ]; then
    build || exit 1
    [ "$dry_run" == 1 ] && exit 0
    emu/ino
    exit $?
fi

poll_src_changes() {
    local file
    inotifywait -m -r -q --format '%w%f' -e CLOSE_WRITE "$filename" src/ --include '.*\.(hpp|cpp|h)$' | while read -r file; do
        rsync "$file" emu/"$file" -u
    done
}

poll_src_changes2() {
    local file
    inotifywait -m -q --format '%w' -e CLOSE_WRITE "$filename" | while read -r file; do
        move_file
    done
}



pidfile=$(tmpfile)
buildfile=$(tmpfile)

__exit() {
    rm "$pidfile" "$buildfile"
    pkill -P "$$" &>/dev/null
    wait
    kill "$$"
    exit 0
}

trap __exit INT

poll_build_changes() {
    inotifywait -m -r -q emu/ -e MOVED_TO -e CLOSE_WRITE --include '.*\.(hpp|cpp|h)$' | while read -r file; do
        echo 1 > "$buildfile"
    done
}

# If watching, don't exit when build fails, just keep watching.
build
[ "$dry_run" == 1 ] && exit 0

poll_src_changes &
poll_src_changes2 &
poll_build_changes &

echo '' > "$pidfile"
echo 1 > "$buildfile"

while true; do
    sleep 0.5
    read -r buildflag < "$buildfile"
    read -r pid < "$pidfile"
    if [ "$buildflag" == 1 ]; then
        sleep 0.5
        
        if make -C emu WINDOW_SCALE="$window_scale"; then
            if [ ! -z "$pid" ]; then
                pkill -P $$
                wait "$pid"
                echo '' > "$pidfile"
            fi

            cp emu/ino emu/ino.watch
            ./emu/ino.watch &
            pid=$!
            echo "$pid" > "$pidfile"
        fi

        echo 0 > "$buildfile"
    elif [ ! -z "$pid" ] && ! ps -p "$pid" >/dev/null; then
        __exit
    fi
done

wait
